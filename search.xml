<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pipenv 试用过程分享</title>
      <link href="/2019/08/04/pipenv-shi-yong-guo-cheng-fen-xiang/"/>
      <url>/2019/08/04/pipenv-shi-yong-guo-cheng-fen-xiang/</url>
      
        <content type="html"><![CDATA[<p>最近常看到pipenv这个管理工具，今天有时间查了下，是 Kennethreitz 大神的作品，看了下github的仓库，是2017年1月份创建的，仅仅一年的时间变获得了7k+的收藏，最新一次的提交时间为2天前，可见该仓库活跃程度。自己之前写过一篇文章《使用 pyenv + virtualenv 打造多版本python开发环境》,遗留个问题，一直没有找到合理的同时管理python和python依赖包的工具，试用了下 pipenv，可以说完美的解决了python版本及包的管理问题。并且pipebv 还是Python.org正式推荐的python包管理工具。原文如下：</p><pre class=" language-flow"><code class="language-flow">   Pipenv — the officially recommended Python packaging tool from Python.org, free (as in freedom).</code></pre><p>那么接下来，分享下我的试用过程，供大家参考：</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>环境 - pipenv 9.0.1 - python3.6 - python2.7</p><h1 id="pipenv-基本概念理解"><a href="#pipenv-基本概念理解" class="headerlink" title="pipenv 基本概念理解"></a>pipenv 基本概念理解</h1><ol><li><p>之前我们使用pip + virtualenv 来管理python依赖包，使用 –python=参数来区分python版本（不再使用pyenv,减少包依赖）。而pipenv的思路简单理解便是把pip和virutalenv 2个工具统一起来，使用 pipenv 来代替。</p></li><li><p>pipenv 使用 Pipfile 来代替 requirement.txt 文件记录python包。</p></li></ol><ol start="3"><li><p>增加了Pipfile.lock 文件来锁定python软件的包名及版本，以及其依赖关系的列表。</p></li><li><p>它参考了其他语言的包管理工具（bundler, composer, npm, cargo, yarn, etc.），旨在将最好的包管理工具带入python世界。</p></li></ol><h1 id="pipenv-功能试用"><a href="#pipenv-功能试用" class="headerlink" title="pipenv 功能试用"></a>pipenv 功能试用</h1><h1 id="pipenv-安装"><a href="#pipenv-安装" class="headerlink" title="pipenv 安装"></a>pipenv 安装</h1><p>普通安装</p><p>pipenv 可使用 pip 直接安装。</p><pre class=" language-flow"><code class="language-flow">   pip install pipenv  </code></pre><p>作者推荐在python3下边安装，会提高与virtualenv的兼容性</p><p>用户模式安装<br>为防止和系统python库产生影响，可使用此种方案安装。</p><pre class=" language-flow"><code class="language-flow">   pip install --user pipenv</code></pre><p>pip 默认安装包路径为/usr/local/lib/python2.7/site-packages。此模式下，pip安装包保存路径为用户库路径,一般为/Users/pylixm/Library/Python/3.6/lib/python/site-packages, 可使用命令python3 -m site –user-site 具体查看。如果在安装后你的shell中pipenv不可用，你需要把用户库的二进制目录/Users/pylixm/Library/Python/3.6/bin添加到你的PATH中。</p><h1 id="pipenv-使用"><a href="#pipenv-使用" class="headerlink" title="pipenv 使用"></a>pipenv 使用</h1><p>初始化虚拟环境</p><p>执行pipenv install，创建虚拟环境，如下：</p><pre class=" language-flow"><code class="language-flow">    ~/laboratory/pip_test_project ⌚ 20:42:10    $ pipenv install    Creating a virtualenv for this project…    ⠋New python executable in /Users/pylixm/.local/share/virtualenvs/pip_test_project-MXA0TC90/bin/python2.7    Also creating executable in /Users/pylixm/.local/share/virtualenvs/pip_test_project-MXA0TC90/bin/python    Installing setuptools, pip, wheel...done.    Virtualenv location: /Users/pylixm/.local/share/virtualenvs/pip_test_project-MXA0TC90    Creating a Pipfile for this project…    Pipfile.lock not found, creating…    Locking [dev-packages] dependencies…    Locking [packages] dependencies…    Updated Pipfile.lock (c23e27)!    Installing dependencies from Pipfile.lock (c23e27)…    ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ 0/0 — 00:00:00    To activate this project's virtualenv, run the following:     $ pipenv shell</code></pre><p>从打印信息可见，它在目录用户目录.local下创建了个和项目同名的虚拟环境(可通过配置环境变量来自定义虚拟环境目录，export WORKON_HOME=~/.venvs)，python使用的是默认的python2.7 。 可通过参数–two 和–three 来泛指python版本，也可通过–python 3.5 来明确知道python版本，但是这些参数的前提是你系统上有此python版本，否则会报如下错误</p><pre class=" language-flow"><code class="language-flow">    $ pipenv --python 3.5    Warning: Python 3.5 was not found on your system…    You can specify specific versions of Python with:    $ pipenv --python path/to/python</code></pre><p>有点像 virtualenv 的 –python参数。</p><p>初始化好虚拟环境后，会在项目目录下生成2个文件Pipfile和Pipfile.lock。为pipenv包的配置文件，代替原来的 requirement.txt。项目提交时，可将Pipfile 文件和Pipfile.lock文件受控提交,待其他开发克隆下载，根据此Pipfile 运行命令pipenv install [–dev]生成自己的虚拟环境。</p><p>Pipfile.lock 文件是通过hash算法将包的名称和版本，及依赖关系生成哈希值，可以保证包的完整性。</p><p>安装python模块</p><p>正常安装</p><p>安装 requests 模块：</p><pre class=" language-flow"><code class="language-flow">    $ pipenv install requests    Installing requests…    Collecting requests      Using cached requests-2.18.4-py2.py3-none-any.whl    Collecting certifi>=2017.4.17 (from requests)      Using cached certifi-2017.11.5-py2.py3-none-any.whl    Collecting idna<2.7,>=2.5 (from requests)      Using cached idna-2.6-py2.py3-none-any.whl    Collecting urllib3<1.23,>=1.21.1 (from requests)      Using cached urllib3-1.22-py2.py3-none-any.whl    Collecting chardet<3.1.0,>=3.0.2 (from requests)      Using cached chardet-3.0.4-py2.py3-none-any.whl    Installing collected packages: certifi, idna, urllib3, chardet, requests    Successfully installed certifi-2017.11.5 chardet-3.0.4 idna-2.6 requests-2.18.4 urllib3-1.22    Adding requests to Pipfile's [packages]…      PS: You have excellent taste!    Locking [dev-packages] dependencies…    Locking [packages] dependencies…    Updated Pipfile.lock (2f8679)! </code></pre><p>可通过命令pipenv graph 查看已安装模块，同时可查看他们直接的相互依赖情况。</p><pre class=" language-flow"><code class="language-flow">   $ pipenv graph    requests==2.18.4      - certifi [required: >=2017.4.17, installed: 2017.11.5]      - chardet [required: <3.1.0,>=3.0.2, installed: 3.0.4]      - idna [required: >=2.5,<2.7, installed: 2.6]      - urllib3 [required: >=1.21.1,<1.23, installed: 1.22]</code></pre><p>只安装开发环境<br>可通过以下命令，仅安装在开发环境,</p><pre class=" language-flow"><code class="language-flow">    pipenv install --dev requests --three</code></pre><p>区别反映在Pipfile 上为:</p><pre class=" language-flow"><code class="language-flow">    [[source]]    url = "https://pypi.python.org/simple"    verify_ssl = true    name = "pypi"    [dev-packages]    [packages]    requests = "*"    flask = "==0.10"    [requires]    python_version = "3.6"</code></pre><p>安装包记录是在[dev-packages] 部分，还是[packages] 部分。在安装时，指定–dev参数，则只安装[dev-packages]下的包,若安装时不定指定–dev参数，只会安装[packages] 包下面的模块。</p><p>[requires] 下的python在构建新的虚拟环境时，若没有会自动下载安装。</p><p>通过 requirements.txt 安装</p><pre class=" language-flow"><code class="language-flow">    pipenv install -r requirements.txt</code></pre><p>这样我们可以重用之前的requirement.txt 文件来构建我们新的开发环境，可以把我们的项目顺利的迁到pipenv。</p><p>可通过以下命令生成requirements 文件：</p><pre class=" language-flow"><code class="language-flow">    pipenv lock -r [--dev] > requirements.txt</code></pre><p>运行虚拟环境<br>可使用以下命令来运行项目：</p><pre class=" language-flow"><code class="language-flow">    pipenv run python xxx.py</code></pre><p>或者启动虚拟环境的shell环境：</p><pre class=" language-flow"><code class="language-flow">    ~/laboratory/pip_test_project    $ pipenv shell --anyway    Spawning environment shell (/bin/zsh). Use 'exit' to leave.    source /Users/pylixm/.local/share/virtualenvs/pip_test_project-MXA0TC90/bin/activate    ~/laboratory/pip_test_project     $ source /Users/pylixm/.local/share/virtualenvs/pip_test_project-MXA0TC90/bin/activate    (pip_test_project-MXA0TC90)    ~/laboratory/pip_test_project    $ exit    ~/laboratory/pip_test_project    $ pipenv shell    Shell for UNKNOWN_VIRTUAL_ENVIRONMENT already activated.    No action taken to avoid nested environments.</code></pre><p>直接运行pipenv shell 并不会出现shell命令行，是应为没有配置环境变量。还需要进一步研究，貌似需要配置环境变了，一直没找到。</p><p>pipenv 提供了.env 文件，放在项目目录下，提供项目所需的环境变量，运行pipenv shell 时，会自动加载。</p><p>删除虚拟环境及包<br>删除包:</p><pre class=" language-flow"><code class="language-flow">    pipenv uninstall reuqests</code></pre><p>删除虚拟环境：</p><pre class=" language-flow"><code class="language-flow">    pipenv --rm </code></pre><p>总结<br>pipenv 完美的解决了python的包和版本的管理。<br>并对包之间的依赖关系也管理起来，方便了开发者构建自己的开发运行环境。<br>时间有限，以上列举的仅为部分功能，更多的强大功能详见官方文档。</p><p>参考<br><a href="https://docs.pipenv.org/" target="_blank" rel="noopener">https://docs.pipenv.org/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用netlify部署项目+HTTPs</title>
      <link href="/2019/07/09/ru-he-shi-yong-netlify-bu-shu-xiang-mu-https/"/>
      <url>/2019/07/09/ru-he-shi-yong-netlify-bu-shu-xiang-mu-https/</url>
      
        <content type="html"><![CDATA[<h1 id="一、使用github或者gitlab登陆netlify"><a href="#一、使用github或者gitlab登陆netlify" class="headerlink" title="一、使用github或者gitlab登陆netlify"></a>一、使用github或者gitlab登陆netlify</h1><p>首先，打开netlify网站(<a href="https://app.netlify.com/" target="_blank" rel="noopener">https://app.netlify.com/</a>)</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5AsjqSEuwwLuTiaw2nWZMlG11hZlno61Hujt1o1dTbsPyu7HXLmt21tw/640?wx_fmt=png" alt="netlify" title="netlify"></p><p>然后使用github或者gitlab账号登录。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5MlxAVE5Wqeu6WFuib05vS96mmcljApFe6ktGP1lDyyI3xI0cam0TYnA/640?wx_fmt=png" alt="登陆图标" title="登陆图标"></p><h1 id="二、根据github-gitlab仓库创建网站"><a href="#二、根据github-gitlab仓库创建网站" class="headerlink" title="二、根据github/gitlab仓库创建网站"></a>二、根据github/gitlab仓库创建网站</h1><p>点击New site from Git按钮：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5Iy1qiayjXeMJ2CmHDBRibmyB6Uv0UWTOrphKTe7SOJicATjkXicJRVCh5w/640?wx_fmt=png" alt="创建图片" title="创建图片"></p><p>根据你的仓库所在平台选择，以下三选一：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5vuuAialPKeaqJ6rrzMRtibkG5REj0cUoJcgLjjMgyuhePXZrjwKOAvyg/640?wx_fmt=png" alt="仓库" title="仓库"></p><p>选择你需要部署的仓库：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5fabMxMqp4uLichvhVdjpvX8m0D5A77D28ffUcYdG9B5uz1FqyNOpK8g/640?wx_fmt=png" alt="仓库2" title="仓库2"></p><p>设置部署选项，包括三点：</p><ol><li><p>部署分支（对应下图中 Branch to deploy）:</p><p>顾名思义就是你的git仓库的分支，默认选择为master分支</p></li><li><p>打包命令（对应下图中 Build command）：</p><p>就是你的打包命令，诸如 npm run build，gulp build 之类；如果本身已是静态文件，不需打包编译，这一栏则不填</p></li><li><p>打包后目录（对应下图中 Publish directory）：</p><p>即执行完打包命令之后静态文件所在目录，诸如 dist，_site 之类；如果本身已是静态文件，这一栏则不填</p></li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5MoMoWM6l8r95W2Q0FSfCDZMibSJJVmmJsDP3bQmgjMoAJRxY1sdrBlQ/640?wx_fmt=png" alt="设置部署选项" title="设置部署选项"></p><p>完成之后点击途中 deploy site 按钮</p><h1 id="三、设置域名，绑定域名"><a href="#三、设置域名，绑定域名" class="headerlink" title="三、设置域名，绑定域名"></a>三、设置域名，绑定域名</h1><p>进行完第二步，我们可以看到自动化部署已经开始运行了，而且过不多久，我们的网站就已经可以利用netlify域名就行访问了，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5SiaWJbSTJqA801PqhvQzKhWh79eGqy4wug1OjLmNK3M7BYpMD2MeSyA/640?wx_fmt=png" alt="域名访问" title="域名访问"></p><p>可以看到netlify为我们随机生成了一个netlify下的域名，这里我们可以更改其前缀，并绑定到我们自己的域名下：</p><blockquote><blockquote><p>更改netlify域名前缀：</p></blockquote></blockquote><p>首先，点击上图中 Site settings 按钮，然后在下方点击 Change site name 按钮，然后在弹出框中输入自己需要更改的前缀名，点击保存即可，如下图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm53OBuIYyK11ibyE6c5eBXK9rCtgdkytMPz6UQic9MzQQslSJYY083w2uw/640?wx_fmt=png" alt="更改域名前缀" title="更改域名前缀"></p><blockquote><blockquote><p>绑定到自己的域名下：</p></blockquote></blockquote><p>首先，点击上上图中 Domain settings 按钮，然后在下方点击 Add custom domain 按钮，然后在弹出框中输入自己需要绑定的完整域名，点击保存，如下图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5tL9CRwYyOH5DDk2iaaNkbgSCsC6b0JibEpB0TYx0qB9TBoyDQYDGTlOg/640?wx_fmt=png" alt="绑定到自己域名" title="绑定到自己域名"></p><p>这个时候会显示 ！Check DNS configuration，因为我们还没有设置域名解析到netlify服务器，所以这个时候需要到你自己域名的相应服务商网站登录之后在需要绑定的域名下添加一条CNAME解析，解析的主机记录即对应的netlify域名值（这里即 codernie.netlify.com）</p><p>ok，过一会儿就可以使用自己的域名访问自己的网站啦</p><h1 id="四、生成HTTPS证书，实现HTTPS访问"><a href="#四、生成HTTPS证书，实现HTTPS访问" class="headerlink" title="四、生成HTTPS证书，实现HTTPS访问"></a>四、生成HTTPS证书，实现HTTPS访问</h1><p>第四部中的Domain settings 中往下拉，可以看到 HTTPS 几个大字母：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5c1iaGicpxZAlqyxFqoGxK36iaUM2aiavZHFo2jur16lj0ShqVBGlReCUibg/640?wx_fmt=png" alt="https证书访问" title="https证书访问"></p><p>点击 Verify DNS configuration 按钮，待它变成下方绿色按钮之后，再点击：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5d8ynozib1aVfDZVWWtZhbIIPCAwMrdLdeg04RHtjOaLjWevVaNicnjSg/640?wx_fmt=png" alt="成功" title="成功"></p><p>然后在弹出框中点击确认，过一会儿之后就可以使用https访问你的小站啦：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5upwiakwa0v7BdND2N2WMN56pQlEcLrMrmFmxAvVFv6pTnkpnYRpVSQQ/640?wx_fmt=png" alt="安全证书" title="安全证书"></p><p>看到自己的小站前面可以有绿色的安全字样，是不是很酷炫，而且很放心，再也不用担心运营商在自己的网站上挂广告啦，哈哈哈。。。等等，是不是还差了点什么：</p><p>对啊，还没有强制跳转https，OK，继续</p><h1 id="五、强制HTTP跳转HTTPS访问"><a href="#五、强制HTTP跳转HTTPS访问" class="headerlink" title="五、强制HTTP跳转HTTPS访问"></a>五、强制HTTP跳转HTTPS访问</h1><p>在第四步 Domain settings 再往下翻一点，可以看到 Force HTTPS，只需点击 Force HTTPS 即可实现，是不是很方便，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rZd1wPibx7PemGDbBG4t2OFxn8VuFvxm5baJlA9RpASX7MqZKSFd3Wnxps63Ip1HKYMibNWQKXRZziaPugDNxmeKA/640?wx_fmt=png%22%E5%BC%BA%E5%88%B6HTTP%E8%B7%B3%E8%BD%ACHTTPS%E8%AE%BF%E9%97%AE%22" alt="强制HTTP跳转HTTPS访问"></p><p>到这里，你的网站即使用户使用http访问，也将强制跳转至https访问啦，这下可以彻底不用担下运营商给你的用户“发红包”啦！</p><h1 id="六、设置redirect"><a href="#六、设置redirect" class="headerlink" title="六、设置redirect"></a>六、设置redirect</h1><p>利用netlify实现自动化部署和HTTPS就写到这里了，喜欢就点个赞啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker使用</title>
      <link href="/2019/07/08/docker-shi-yong/"/>
      <url>/2019/07/08/docker-shi-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="1-本地使用镜像"><a href="#1-本地使用镜像" class="headerlink" title="1 本地使用镜像"></a>1 本地使用镜像</h3><p>启动 docker run -i -t ubuntn /bin/bash</p><p>如果是 CTRL+P+Q方式退出来了 就会变成后天运行</p><p>想再次进入。<br>docker attach 容器ID     </p><p>当然，如果直接是以exit的方式退出的，如果要重新启动容器，可以不需要使用docker run的方式，还可以使用如下命令重新启动，</p><p>重启退出的容器<br>docker start  【容器ID或容器名称】   (这样重启后。nginx服务可能不会重启)，所以要使用守护进程的方式启动、   docker exec name nginx<br>docker restart 【容器ID或容器名称】</p><p>查看刚刚建立的容器</p><p>docker inspect ID或者名字</p><p>删除掉某个容器<br>docker rm 容器ID或者名字</p><p>docker rmi -f 容器ID或者名字   -f是强制删除</p><p>删除所有镜像  -q</p><p>docker rmi $(docker images -q)   这个是删除无版图中所有的镜像</p><p>查看启动的容器  docker ps -a</p><p>使用 docker inspect ID 或者name可以查看  容器的ipaddress</p><p>守护进程 并启动nginx<br>docker exec name servername</p><p>docker exec -i -t name /bin/bash</p><p>停止守护容器</p><p>docker stop </p><p>docker kill</p><p>安装nginx apt-get install -y nginx<br>安装vim apt-get install -y vim</p><p>whereis 查找nginx安装在哪里  whereis nginx</p><p>把nginx配置文件的root值 改为网站目录</p><p>路径是:etc/nginx/sites-enabled/default</p><p>然后启动直接启动 :nginx</p><p>ps -ef可以查看起了那些进程</p><p>然后就可以退出这个容器了 ctrl+p+q</p><p>查看容器启动的端口 docker port webname</p><p>查看容器启动的进程  docker top webname</p><h3 id="2-线上本地联合使用镜像-查找-拉取-推送"><a href="#2-线上本地联合使用镜像-查找-拉取-推送" class="headerlink" title="2 线上本地联合使用镜像 查找 拉取 推送"></a>2 线上本地联合使用镜像 查找 拉取 推送</h3><p>查找镜像有两种 第一种是去docker hub  第二种是docker search name 命令查找</p><p>docker search中还可以有星级限制</p><p>比如查找三星以上的  docker search -s 3 ubuntu</p><p>换镜像的源： –registry-mirror<br>1：修改:   /etc/default/docker<br>2 添加: DOCKER_OPTS= “–registry-mirror=<a href="http://MIRROR-ADDR”" target="_blank" rel="noopener">http://MIRROR-ADDR”</a></p><p>使用daocloud<br><a href="https://www.daocloud.io" target="_blank" rel="noopener">https://www.daocloud.io</a></p><p>注册以后就可以用加速器。然后生成一个连接。把连接复制到docker文件里面</p><p>推到docker hub上docker push name</p><p>然后输入密码就可以了<br>然后就可以再网站上找到镜像了</p><p>###3 构建镜像<br>通过容器构建<br>docker commit name</p><p>-a  来指定作者</p><p>-m  来留信息 </p><p>-p 不暂停正在进行的容器<br>通过dockerfile文件构建</p><p>docker build   通过dockerfile文件构建</p><p>先启动一个交互式容器docker run -it -p 80 –name commit_test ubuntu /bin/bash   并改个名字</p><p>然后就进入容器了apt-get update 更新一下  安个nginx后就可以 exit退出提交镜像了</p><p>提交镜像</p><p>docker commit 容器ID或者name  -a ‘lhj’ -m ‘ngnix’ 镜像名字 ommit_test1</p><p>然后就可以docker images查看到自己的镜像</p><p>然后就可启动这个新创建的镜像  并且指定容器的端口  </p><p>docker run -d –name ngingweb -p 80 镜像名 nginx -g ‘daemon off;’</p><p>这么做的好处就是 之前在源镜像的修改。打包成了一个新的镜像。这样每次执行新镜像就可以了</p><p>###4  使用dockerfile+build构建镜像</p><p>1创建dockerfile 编写</p><p>FROM ubuntu:latest</p><p>MAINTAINER dormancypress “<a href="mailto:luhongjie@qq.com" target="_blank" rel="noopener">luhongjie@qq.com</a>“</p><p>RUN apt-get update</p><p>RUN apt-get install -y ngnix </p><p>EXPOST 80</p><p>2使用docker build命令</p><p>docker build [options] PATH | URL | -</p><p> -t 构建出来的名字</p><p>docker build -t =’test1’ .  注意这个点 是当前目录</p><p>然后docker images就可以看到构建出来的镜像</p><p>在启动个打包好的镜像，并且填写好80端口</p><p>docker run -d –name testnew -p 80  镜像名 ngnix -g ‘deamon off;’   千万不要忘了加这个分号</p><p>###5 docker的守护进程的各种服务端修改</p><p>service 命令管理</p><p>sudo service docker start </p><p>sudo service docker stop </p><p>sudo service docker restart</p><p>启动守护进程</p><p>docker -d </p><p>vim打开启动配置文件</p><p>/etc/default/docker<br>可以加一个默认配置选项</p><p>DOCKER_OPT=”lABEL NAME =DOCKER_SERVER_1”   默认docker名字是docker server</p><p>然后在service docker restart 重启</p><p>ps -ef | grep docker 查找过滤的  就可以找到name等于docker_server_1  名字变了 </p><p>#####修改服务器端配置</p><p>1 修改docker守护进程启动选项</p><p>-H选项的值</p><p>-H tcp://host:port,<br>   unix:///path/to/socket,<br>   fd://* or jd://sockerfd</p><p>一般更改都是unix socket连接 </p><p>默认情况docker的守护进程 使用unix:///var/run/docker.sock的配置</p><p>###6  dockerfile指令(上) –指令格式</p><p>EXPOSE port</p><p>指定运行镜像的端口  EXPOSE 80</p><p>CMD   在容器启动的时候，运行   [“/usr/sbin/nginx”,”g”,”daemon off;” ]<br>ENTERYPOINT    和CMD差不多    来源地址和目标地址<br>ADD    复制文件或者目录到使用dockerfile构建的镜像中   [“<src>“…”<dest>“]  也可以是远程地址<br>COPY  类似于 ADD  COPY index.html /usr/share/nginx/html/   替换nginx里面的文件<br>VOLUME 向容器添加data<br>WORKDIR  在创建的时候 在容器内部设置工作目录 WORKDIR /a<br>ENV  环境变量指令 和workdir一样<br>USER  指定镜像使用的用户   USER nginx   不指用 ，默认就会用root用户<br>ONBUILD     添加触发器 当一个镜像被其他镜像用作基础镜像的时候。这个镜像会被触发执行  [“/usr/sbin/nginx”,”g”,”daemon off;”]</dest></src></p><p>从基础镜像运行一个容器</p><p>执行一条指令，对容器做出修改</p><p>####dockerfile 构建的过程</p><p>从基础镜像运行一个容器</p><p>执行一条指令,对容器做出修改</p><p>执行类似docker commit 的操作，提交一个新的镜像曾</p><p>再基于刚提交的镜像运行一个新容器</p><p>执行dockerfile中的下一条指令。直至所有指令执行完毕</p><p>docker中有构建缓存，用Build构建的时候。会有缓存</p><p>不使用缓存：docker build –no-cache</p><p>刷新缓存：<br>docker history  [image]</p><h3 id="docker容器的网络连接"><a href="#docker容器的网络连接" class="headerlink" title="docker容器的网络连接"></a>docker容器的网络连接</h3><p>linux虚拟网桥的特点</p><p>可以自己设置IP</p><p>相当于有一个隐藏的虚拟网卡</p><p>docker0的肚子鼓</p><p>IP：172.17.42.1  子网掩码：255.255.0.0</p><p>MAC：02:42：ac：11:00：00到02:42：ac：11：ff:ff</p><p>总共65534个地址</p><p>可以APT安装 bridge-utils</p><p>brctl show来查看网桥设备</p><p>一般RUN一个docker容器  就会自动分配一个eth0的网桥设备   然后退出这个容器的时候  brctl show查看  就会查到退出容器的网桥设备</p><p>2 修改docker0地址</p><p>sudo ifconfig docker0 192.168.200.1 netmask 255.255.255.0</p><p>3自定义 虚拟网桥</p><p>1 建立一个虚拟网桥</p><p>2在守护进程启动配置添加虚拟网桥  </p><p>/etc/default/docker 中添加DOCKER_OPS值  -b=br0</p><p>添加虚拟网桥用brctl addbr bro    addbr命令添加</p><p>然后ifconfig给新添加的虚拟网桥 设置IP地址和子网掩码</p><p>在文件末尾添加</p><p>DOCKER_OPTS=’ b=br0’</p><p>service docker restart 重启服务端</p><p>然后run一个容器  进去。ifconfig看看连接到新的网桥没有</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做一个仓鼠发电机</title>
      <link href="/2019/07/08/ru-he-zuo-yi-ge-cang-shu-fa-dian-ji/"/>
      <url>/2019/07/08/ru-he-zuo-yi-ge-cang-shu-fa-dian-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="仓鼠发电机制作方法"><a href="#仓鼠发电机制作方法" class="headerlink" title="仓鼠发电机制作方法"></a>仓鼠发电机制作方法</h1><p>一只小仓鼠</p><p><img src="http://file.elecfans.com/web1/M00/63/B6/pIYBAFuXq2iAHuLzAACA3UHoAOU905.jpg" alt="小仓鼠" title="小仓鼠"></p><p>找了很久，都没有找到仓鼠发电机的制作方法。历经千辛万苦，终于在国外的一个网站找到了制作方法，现呈现给大家。（大家也不用浪费时间找了，此文即为终极版）</p><p>第一步：请确保你的仓鼠喜欢跑！如果不跑，属于品种问题，与人品无关。大多数的老鼠，可以转到40-60圈每分钟。</p><p>第二步：轴承的选择。这里选择的是球轴承，即自行车上的那种，因为发现如果直接把轴固定在鼠笼子上，会浪费很多的能量，而这些能量本来可以转换成电能。这个部件应该不难找到。</p><p><img src="http://file.elecfans.com/web1/M00/63/98/o4YBAFuXqw6AC65iAAAm0Gfo8Bk488.jpg" alt="轴承" title="轴承"></p><p>第三步：安装老鼠的转轮到轴承上。不知道这个轮子哪里来的，感觉不爽的话，自己做一个吧。</p><p><img src="http://file.elecfans.com/web1/M00/63/99/o4YBAFuXqw6ACEadAADImhFddwA417.jpg" alt="跑轮" title="跑轮"></p><p>仓鼠的“跑步机”</p><p><img src="http://file.elecfans.com/web1/M00/63/B6/pIYBAFuXq2iABMgiAABxoeeXNik779.jpg" alt="背板" title="背板"></p><p>背面观（左右两个红色的，是两个线圈）</p><p>第四步：安装永磁铁。这里永磁铁的设计比较巧妙，用了一个铁环，上面用胶水固定了一圈小磁铁。不要小看了这种小磁铁，其磁力相当强。很多地方都能买到。至于那个铁环，用易拉罐之类的剪一个就可以了。这个贴满了小磁铁的铁环，最后固定在了转轮的背侧。</p><p><img src="http://file.elecfans.com/web1/M00/63/99/o4YBAFuXqw6ASnP7AACbd0Sxplc262.jpg" alt="磁铁" title="磁铁"></p><p>第五步：线圈的安装。线圈不是现成了，自己绕吧，每个绕个400圈，一共需要两个，因为发现一个线圈产生的电压太低。注意：线圈的内径应该约等于小磁铁的直径。</p><p>这两个线圈怎样连接？第一个线圈的一头与第二个线圈的一头相连。怎样知道线圈放反了没有？最好的办法就是拿个电压表来试试。把第二个线圈取下，转动轮子，测其电压为V，将第二个线圈装上，此时的电压应该为2V，如果电压为0，说明第二个线圈是反的，掉个头应该就可以了。</p><p>总结一下：据说，这发电机最终点亮了6个LED灯！喜欢动手的朋友们试着自己做一个。（声明：此文乃根据本人的理解自己打出来的，不保证其权威性。英文比较好的朋友，</p><p>请参考原文：<a href="http://www.otherpower.com/hamster.html）" target="_blank" rel="noopener">http://www.otherpower.com/hamster.html）</a></p><p><img src="http://file.elecfans.com/web1/M00/63/B6/pIYBAFuXq2iARav2AACzN5HeqsE900.jpg" alt="磁铁" title="磁铁"></p><p><img src="http://file.elecfans.com/web1/M00/63/99/o4YBAFuXqw6ARlfHAADKEVhRwFs847.jpg" alt="磁铁" title="磁铁"></p><p><img src="http://file.elecfans.com/web1/M00/63/B6/pIYBAFuXq2iAa3EsAAEmB5teIyE942.jpg" alt="磁铁" title="磁铁"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 稀奇百怪的想法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门,使用docker部署NodeJs应用(转)</title>
      <link href="/2019/07/07/docker-bu-shu-nodejs/"/>
      <url>/2019/07/07/docker-bu-shu-nodejs/</url>
      
        <content type="html"><![CDATA[<h1 id="docker入门-使用docker部署NodeJs应用"><a href="#docker入门-使用docker部署NodeJs应用" class="headerlink" title="docker入门,使用docker部署NodeJs应用"></a>docker入门,使用docker部署NodeJs应用</h1><h2 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h2><p><img src="http://img.shepherd618.cn/docker.jpg" alt="docker" title="docker"></p><p>docker是一个开源的应用容器引擎，可以为我们提供安全、可移植、可重复的自动化部署的方式。docker采用虚拟化的技术来虚拟化出应用程序的运行环境。如上图一样。docker就像一艘轮船。而轮船上面的每个小箱子可以看成我们需要部署的一个个应用。使用docker可以充分利用服务器的系统资源，简化了自动化部署和运维的繁琐流程,减少很多因为开发环境中和生产环境中的不同引发的异常问题。从而提高生产力。</p><p>docker三个核心概念如下：</p><ul><li>镜像（images）：一个只读的模板，可以理解为应用程序的运行环境，包含了程序运行所依赖的环境和基本配置。相当于上图中的每个小箱子里面装的东西。</li></ul><ul><li>仓库（repository）：一个用于存放镜像文件的仓库。可以看做和gitlab一样。</li></ul><ul><li>容器（container）：一个运行应用程序的虚拟容器，他和镜像最大的区别在于容器的最上面那一层是可读可写的。 相当于上图中的每个小箱子里。</li></ul><h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><p>mac</p><p><a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">官网下载地址，点击下载即可。</a></p><p>liunx</p><p>打开终端 输入</p><p><code>curl https://releases.rancher.com/install-docker/17.12.sh | sh</code></p><p>等待安装完成。检查是否安装成功。</p><p>docker -v</p><p>环境已经安装完毕。现在来开始部署应用吧。</p><h1 id="docker实战"><a href="#docker实战" class="headerlink" title="docker实战"></a>docker实战</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><label style="color:blue">准备工作</label></h2><h2 id="初始化一个NodeJs程序"><a href="#初始化一个NodeJs程序" class="headerlink" title="初始化一个NodeJs程序"></a><label style="color:blue">初始化一个NodeJs程序</label></h2><p> 以下操作必须已经安装了NodeJS。如果没有安装请参照之前的教程传送门<br>首先创建一个空文件夹。并创建以下文件：</p><ul><li>server.js</li></ul><ul><li>package.json</li></ul><ul><li>Dockerfile</li><li>.dockerignore</li></ul><pre class=" language-flow"><code class="language-flow">    mkdir docker_demo    cd docker_demo    touch server.js    touch package.json    touch Dockerfile    touch .dockerignore</code></pre><p>然后在server.js写入</p><pre class=" language-flow"><code class="language-flow">   const Koa = require('koa');    const app = new Koa();    app.use(async ctx => {    ctx.body = 'Hello docker';    });    app.listen(3000);</code></pre><p>在package.json中写入</p><pre class=" language-flow"><code class="language-flow">   {        "name": "docker_demo",        "version": "0.1.0",        "private": true,        "scripts": {            "start": "node server.js"        },        "dependencies": {          "koa": "^2.5.0"        }    }</code></pre><p>测试程序。控制台输入</p><pre class=" language-flow"><code class="language-flow">  npm start</code></pre><p>浏览器打开本地测试,如果如图所示。表示demo创建成功。请继续往下。</p><p><img src="http://img.shepherd618.cn/docker_test.png" alt="启动成功" title="启动成功"></p><h2 id="创建dockerfile文件"><a href="#创建dockerfile文件" class="headerlink" title="创建dockerfile文件"></a><label style="color:blue">创建dockerfile文件</label></h2><p>   Dockerfile是由一系列命令和参数构成的脚本，一个Dockerfile里面包含了构建整个image的完整命令。Docker通过docker build执行Dockerfile中的一系列命令自动构建image.<br>在.dockerignore文件里面写入代码。表示过滤该类型的文件。类似git的.gitignore</p><pre class=" language-flow"><code class="language-flow">   # Logs    logs    *.log    npm-debug.log*    # Runtime data    pids    *.pid    *.seed    # Directory for instrumented libs generated by jscoverage/JSCover    lib-cov    # Coverage directory used by tools like istanbul    coverage    # nyc test coverage    .nyc_output    # Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)    .grunt    # node-waf configuration    .lock-wscript    # Compiled binary addons (http://nodejs.org/api/addons.html)    build/Release    # Dependency directories    node_modules    jspm_packages    # Optional npm cache directory    .npm    # Optional REPL history    .node_repl_history    .idea    .node_modules    node_modules    .vscode</code></pre><p>在Dockerfile文件中写入以下代码：</p><pre class=" language-flow"><code class="language-flow">  #制定node镜像的版本    FROM node:8.9-alpine    #声明作者    MAINTAINER robin    #移动当前目录下面的文件到app目录下    ADD . /app/    #进入到app目录下面，类似cd    WORKDIR /app    #安装依赖    RUN npm install    #对外暴露的端口    EXPOSE 3000    #程序启动脚本    CMD ["npm", "start"]</code></pre><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a><label style="color:blue">构建镜像</label></h2><p>使用build命令构造镜像,注意后面那个.不能少。</p><pre class=" language-flow"><code class="language-flow">   docker build -t docker_demo .</code></pre><pre class=" language-flow"><code class="language-flow">    robin:docker_demo robin$ docker build -t docker_demo .    Sending build context to Docker daemon  39.94kB    Step 1/7 : FROM node:8.9-alpine    ---> 406f227b21f5    Step 2/7 : MAINTAINER robin    ---> Using cache    ---> 78d6cdbcfee2    Step 3/7 : ADD . /app/    ---> 2cb30678612d    Step 4/7 : WORKDIR /app    Removing intermediate container e51377081039    ---> c2b7d0f37d2d    Step 5/7 : RUN npm install    ---> Running in da0c3946ca8d    npm notice created a lockfile as package-lock.json. You should commit this file.    added 38 packages in 3.323s    Removing intermediate container da0c3946ca8d    ---> eecee87f10e2    Step 6/7 : EXPOSE 3000    ---> Running in f3973cc168a4    Removing intermediate container f3973cc168a4    ---> 2671a4c6deb4    Step 7/7 : CMD ["npm", "start"]    ---> Running in dec529f754aa    Removing intermediate container dec529f754aa    ---> 6ec73793d353    Successfully built 6ec73793d353    Successfully tagged docker_demo:latest</code></pre><p>等待镜像构造完成。然后使用 images命令查看镜像。</p><p><img src="http://img.shepherd618.cn/docker_images.png" alt="查看镜像" title="查看镜像"></p><p>此时可以看到images已经构造完成。现在开始启动images，并测试。</p><p><img src="http://img.shepherd618.cn/docker_images.png" alt="查看镜像" title="查看镜像"></p><pre class=" language-flow"><code class="language-flow">   #启动镜像 -d表示后台执行，-p 9000:3000表示指定本地的9000端口隐射到容器内的3000端口，docker_demo为镜像名称    docker run -d -p 9000:3000 docker_demo    #查看容器    docker ps</code></pre><p><img src="http://img.shepherd618.cn/docker_run.png" alt="查看容器" title="查看容器"></p><p>此时浏览器打开<a href="http://localhost:9000/,如果如图所示。表示容器运行正常。" target="_blank" rel="noopener">http://localhost:9000/,如果如图所示。表示容器运行正常。</a></p><p><img src="http://img.shepherd618.cn/docker_test.png" alt="成功启动" title="成功启动"></p><p>如果此时本地无法打开。可以使用log命令查看日志。根据日志修改对应出现的对方。</p><h2 id="绑定docke-hub"><a href="#绑定docke-hub" class="headerlink" title="绑定docke hub"></a><label style="color:blue">绑定docke hub</label></h2><p>镜像已经存在了我们本机硬盘，那我们实际中要么上传到服务器呢？这里通常有2个方法。一直是自己搭建镜像仓库比如（harbor）,还有就是官方的docke hub，类似gitlab。我们这里先以docke hub为列。harbor放在下篇博客。首先需要注册docke hub账号,<a href="https://hub.docker.com/" target="_blank" rel="noopener">官网注册地址</a>。然后登陆。</p><pre class=" language-flow"><code class="language-flow">    robin:docker_demo robin$ docker login    Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.    Username:xxxxxx    Password:     Login Succeeded    robin:docker_demo robin$ </code></pre><p>登陆成功之后。需要给当前images。添加tag,并push</p><pre class=" language-flow"><code class="language-flow">   #格式docker tag 标签名 用户名/标签名    docker tag docker_demo robin365/docker_demo    #格式docker push 用户名/标签名    docker push robin365/docker_demo</code></pre><p>完成之后,可以登陆<a href="https://hub.docker.com/" target="_blank" rel="noopener">docke hub</a>。查看刚刚push的镜像。我们可以设置这个镜像是否公开。Public：所有人都可以下载。Private：表示自己才能下载</p><p><img src="http://img.shepherd618.cn/image_s.png" alt="成功启动" title="成功启动"></p><p>这样我们已经把images上传到docke hub了,在我们需要用到这个images的时候可以直接通过docker pull命令下载使用了。<br>到此本教程结束。实际项目中部署可能会出现各种各样的问题，我们需要多查看log。根据log去做相应修改。后面我也会整理出有关docke在部署nodejs应用中的一些比较容易出错的地方。</p><h1 id="dockerc-常用命令"><a href="#dockerc-常用命令" class="headerlink" title="dockerc 常用命令"></a>dockerc 常用命令</h1><pre class=" language-flow"><code class="language-flow">    #查看当前docker版本    docker -v    #查看当前本地所有镜像    docker images    #构造镜像,用法docker build -t 镜像名称 .    docker build -t docker_demo .    #用于容器与主机之间的数据拷贝。用法docker cp 主机文件地址 容器内地址。12d7f14v45cv为容器id。    docker cp /www/runoob 12d7f14v45cv:/www/    #创建一个新的容器并运行，-d为后台执行，-p 9000:3000前面为主机端口，后面是容器端口。docker_demo镜像名    docker run -d -p 9000:3000 docker_demo    #启动已被停止的容器    docker start docker_demo    #关闭已被启动的容器    docker stop docker_demo    #重新启动容器    docker restart docker_demo    #杀掉一个运行中的容器。    docker kill -s KILL docker_demo    #删除一个或多少容器。-f :通过SIGKILL信号强制删除一个运行中的容器-l :移除容器间的网络连接，而非容器本身-v :-v 删除与容器关联的卷    docker rm -f docker_demo、docker_demo1    #在运行的容器中执行命令。104e28f2f072容器id    sudo docker exec -it 104e28f2f072 /bin/bash     #列出容器。 -a:所有容器包含没有运行的    docker ps     #获取容器获取容器的日志 104e28f2f072容器id，-t:显示时间戳    docker logs -f -t 104e28f2f072     #登陆镜像仓库    docker login    #获取镜像    docker pull     #上传镜像    docker push    #查看指定镜像的创建历史。    docker history docker_demo</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> docker nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法学习</title>
      <link href="/2019/07/05/markdown/"/>
      <url>/2019/07/05/markdown/</url>
      
        <content type="html"><![CDATA[<p>语法简明概述<br>分段 两个回车<br>换行 两个空格 + 回车<br>标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题<br>强调 <strong>文字</strong> ， <strong>文字</strong> ， <em>文字</em> ， <em>文字</em> ， 文字<br>引用 &gt; 注意后面紧跟个空格<br>表格 - 和 | 分割行和列 ， : 控制对其方式<br>代码块 四个空格 开头或， 使用<code>代码内容</code><br>链接 <a href="链接地址">文字</a><br>图片 <img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="图片说明"> ，地址可以是本地路劲，也可以是网络地址<br>列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格</p><p>Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。</p><h1 id="一-标题"><a href="#一-标题" class="headerlink" title="一:标题"></a>一:标题</h1><p>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字</p><p>示例：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="二-语法"><a href="#二-语法" class="headerlink" title="二:语法"></a>二:语法</h1><p>加粗<br>要加粗的文字左右分别用两个*号包起来</p><p>斜体<br>要倾斜的文字左右分别用一个*号包起来</p><p>斜体加粗<br>要倾斜和加粗的文字左右分别用三个*号包起来</p><p>删除线<br>要加删除线的文字左右分别用两个~~号包起来</p><p>示例：</p><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><h1 id="三-引用"><a href="#三-引用" class="headerlink" title="三:引用"></a>三:引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…<br>貌似可以一直加下去，但没神马卵用</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><hr><hr><hr><hr><p>可以看到，显示效果是一样的。</p><h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p>语法：</p><p>![图片alt](图片地址 ‘’图片title’’)</p><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p><p>示例：</p><p><img src="https://i.loli.net/2019/07/06/5d2017eae1d6048033.jpg" alt="blockchain" title="区块链"></p><h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p>语法：<br><a href="超链接地址" title="超链接title">超链接名</a><br>title可加可不加</p><p>示例：</p><p><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替</p><p><a href="超链接地址" target="_blank">超链接名</a></p><p>示例<br><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank">简书</a></p><h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><p>无序列表</p><p>语法：<br>无序列表用 - + * 任何一种都可以</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><p>注意：- + * 跟内容之间都要有一个空格</p><p>语法：<br>有序列表</p><p>数字加点</p><p>1.列表内容<br>2.列表内容<br>3.列表内容</p><p>注意：序号跟内容之间要有空格</p><p>列表嵌套</p><p>上一级和下一级之间敲三个空格即可</p><p>一级无序列表内容<br>   二级无序列表内容<br>   二级无序列表内容<br>   二级无序列表内容</p><p>一级无序列表内容</p><p>   二级有序列表内容</p><h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法:</p><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><p>第二行分割表头和内容。</p><ul><li>有一个就行，为了对齐，多加了几个<br>文字默认居左</li><li>两边加：表示文字居中</li><li>右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略</li></ul><p>示例：</p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><p>  <code>代码内容</code></p><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><p>(<code>)  代码...  代码...  代码...(</code>)</p><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p><p>示例：</p><p>单行代码</p><p><code>create database hero;</code></p><p>代码块</p><p>(<code>)    function fun(){         echo &quot;这是一句非常牛逼的代码&quot;;    }    fun();(</code>)</p><h1 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h1><pre class=" language-flow"><code class="language-flow">st=>start: 开始 e=>end: 登录 io1=>inputoutput: 输入用户名密码 sub1=>subroutine: 数据库查询子类 cond=>condition: 是否有此用户 cond2=>condition: 密码是否正确 op=>operation: 读入用户信息st->io1->sub1->cond cond(yes,right)->cond2 cond(no)->io1(right) cond2(yes,right)->op->e cond2(no)->io1 </code></pre><h1 id="十一-更改字体、大小、颜色"><a href="#十一-更改字体、大小、颜色" class="headerlink" title="# 十一,更改字体、大小、颜色"></a># 十一,更改字体、大小、颜色</h1><p><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="red">我是红色</font><br><font color="#008000">我是绿色</font><br><font color="Blue">我是蓝色</font><br><font size="5">我是尺寸</font><br><font face="黑体" color="green" size="5">我是黑体，绿色，尺寸为5</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
